<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.5">
<meta name="author" content="Patrick Gundlach">
<title>RELAX NG Tutorial</title>
<link rel="stylesheet" href="css/relaxng.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
</head>
<body class="article">
<div id="header">
<h1>RELAX NG Tutorial</h1>
<div class="details">
<span id="author" class="author">Patrick Gundlach</span><br>
<span id="email" class="email"><a href="mailto:gundlach@speedata.de">gundlach@speedata.de</a></span><br>
<span id="revnumber">version 0.1,</span>
<span id="revdate">2017-08-02</span>
</div>
<div id="toc" class="toc">
<div id="toctitle">Inhalt</div>
<ul class="sectlevel1">
<li><a href="#_los_geht_s">1. Los geht&#8217;s</a></li>
<li><a href="#_attribute">2. Attribute</a></li>
<li><a href="#_optionale_elemente_und_attribute">3. Optionale Elemente und Attribute</a></li>
<li><a href="#_auswahl_choice">4. Auswahl (Choice)</a></li>
<li><a href="#_benannte_muster">5. Benannte Muster</a></li>
<li><a href="#_datentypen">6. Datentypen</a></li>
<li><a href="#_vorbelegte_werte">7. Vorbelegte Werte</a></li>
<li><a href="#_listen">8. Listen</a></li>
<li><a href="#_verschachteln_von_elementen_interleave">9. Verschachteln von Elementen (interleave)</a></li>
<li><a href="#_mehrfachdefinitionen_combine">10. Mehrfachdefinitionen (combine )</a></li>
<li><a href="#_mehrere_schemadateien">11. Mehrere Schemadateien</a></li>
<li><a href="#_namensräume_namespaces">12. Namensräume (Namespaces)</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<h2 id="_vorwort" class="discrete">Vorwort</h2>
<div class="paragraph">
<p>RELAX NG (gesprochen: relaxing) ist eine Schemasprache für XML, mit der man den Aufbau eines XML-Dokuments beschreiben kann.
Hat man ein solches Schema erstellt, dann kann man leicht überprüfen, ob ein XML-Dokument den Anforderungen entspricht.
Beispielsweise kann man in einem Schema festlegen, dass ein Adressbucheintrag genau einen Vornamen und einen Nachnamen enthalten muss.
Das hat zwei Vorteile:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Der Anwender kann prüfen, ob das XML-Dokument den Anforderungen entspricht (Validierung).</p>
</li>
<li>
<p>Mit einem passenden Editor kann sich per Autovervollständigung Vorschläge für die Eingabe geben lassen und spart Tipparbeit und vermeidet Fehler.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Die Schemasprache RELAX NG eignet sich sehr gut für diese Aufgabe und wird von vielen XML-Editoren unterstützt.
RELAX NG kommt in zwei Arten daher, die funktional identisch sind.
Einmal als »kompakte Syntax« und einmal als »XML-Syntax«. In diesem Dokument wird nur die XML-Syntax beschrieben.</p>
</div>
<div class="paragraph">
<p>Dieses Tutorial lehnt sich an das »offizielle« Tutorial an, das auf der <a href="http://relaxng.org/tutorial-20030326.html">RELAX NG-Webseite zur Verfügung steht</a>.
Es ist keine direkte Übersetzung.
Hier und da wurden Änderungen vorgenommen, um den Inhalt leichter zu vermitteln.
Hinweise auf nicht mehr übliche Techniken wurden entfernt (TREX, DTD, &#8230;&#8203;)</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Neu eingeführte Elemente werden im linken Rand dargestellt. Damit kannst du das Tutorial auch »überfliegen«, wenn du nach einem bestimmten Befehl suchst. Das funktioniert leider nur, wenn der Bildschirm groß genug ist&#8230;&#8203;
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Dieses Dokument unterliegt der <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.de">CC-By-SA Lizenz</a>. Der Quelltext (Asciidoctor) des Dokuments ist auf <a href="https://github.com/speedata/relaxngtutorial-de">Github</a> zu finden.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_los_geht_s">1. Los geht&#8217;s</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Als Beispiel für das Tutorial (bzw. die ersten Schritte) soll folgende XML-Datei dienen, für die ein Schema erstellt werden soll (speichern z.B. unter <code>source.xml</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;addressBook&gt;
  &lt;card&gt;
    &lt;name&gt;John Smith&lt;/name&gt;
    &lt;email&gt;js@example.com&lt;/email&gt;
  &lt;/card&gt;
  &lt;card&gt;
    &lt;name&gt;Fred Bloggs&lt;/name&gt;
    &lt;email&gt;fb@example.net&lt;/email&gt;
  &lt;/card&gt;
&lt;/addressBook&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das dazugehörige Schema könnte wie folgt aussehen (speichern z.B. unter <code>schema.rng</code>):</p>
</div>
<code class="sidebar">
element<br>
zeroOrMore<br>
text
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Es ist schwierig ein Schema aus einer XML-Datei zu erzeugen, wenn nicht genügend Informationen über die Datei bekannt sind. Ist das Feld <code>email</code> zwingend notwendig? Dürfen noch weitere Elemente hinzukommen? Ohne die Antworten zu kennen, ist das dazugehörige Schema möglicherweise unvollständig. Das soll im Tutorial aber nicht weiter stören, da wir uns nur die Schemasprache anschauen.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Die Validierung des Dokuments wird meist in einem XML-Editor durchgeführt (z.B. oXygen XML), in der Regel auch während der Eingabe.
Man kann mit dem Programm <a href="http://www.thaiopensource.com/relaxng/jing.html">Jing</a> auch auf der Kommandozeile validieren, das ist aber natürlich etwas umständlicher, für automatisierte Workflows aber extrem praktisch:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh" data-lang="sh">java -jar jing.jar schema.rng source.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Passt die XML-Datei zum Schema, so gibt es keine Ausgabe und der Rückgabewert des Programms ist 0.
Andernfalls wird eine Fehlermeldung ausgegeben.</p>
</div>
<div class="paragraph">
<p>Das oben gezeigte Schema erwartet als Wurzelelement ein Element mit dem Namen <code>addressBook</code> mit keinem oder mehreren Kindelementen <code>card</code>, die wiederum zwei Elemente (<code>name</code> und <code>email</code>) in dieser Reihenfolge enthalten. Beide Kindelemente müssen vorhanden sein und enthalten beliebigen Text, der auch leer sein kann. Mit etwas Geduld kann man das ganz gut aus dem Schema ablesen.</p>
</div>
<code class="sidebar">
oneOrMore</code>
<div class="paragraph">
<p>Möchte man z.B. dass <code>addressBook</code> mindestens ein Element <code>card</code> enthält, dann ersetzt man <code>zeroOrMore</code> durch <code>oneOrMore</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;oneOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/oneOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_attribute">2. Attribute</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Falls anstelle von Elementen Attribute gewünscht sind, kann man das einfach erreichen. Dazu passt man das Schema an und ersetzt quasi die <code>&lt;element ..&gt;</code> durch <code>&lt;attribute ..&gt;</code>:</p>
</div>
<code class="sidebar">
attribute
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;attribute name="name" /&gt;
      &lt;attribute name="email" /&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Da die Reihenfolge der Attribute in XML nicht wichtig ist, können sie bei RELAX NG auch in beliebiger Reihenfolge festgelegt werden. Bei Elementen hingegen ist die Reihenfolge wesentlich.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Es gibt einen Unterschied zwischen den Mustern für Attribute und Elemente. Die Voreinstellung für den Inhalt von Attributen ist <code>&lt;text /&gt;</code>. Daraus folgt, dass</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;attribute name="email"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>die Kurzform für</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;attribute name="email"&gt;
  &lt;text/&gt;
&lt;/attribute&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ist. Für Elemente hingegen gibt es keine Voreinstellung.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- nicht erlaubt! --&gt;
&lt;element name="email"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Leere Elemente müssen explizit als solche gekennzeichnet sein.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- aber das hier ist erlaubt --&gt;
&lt;element name="email"&gt;
  &lt;empty /&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ist hingegen ein Attribut erlaubt, ist das <code>&lt;empty /&gt;</code> nicht notwendig, wird aber implizit angenommen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="card"&gt;
  &lt;attribute name="email" /&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ist dasselbe wie</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="card"&gt;
  &lt;attribute name="email" /&gt;
  &lt;empty/&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<h3 id="_namensraum_des_schemas" class="discrete">Namensraum des Schemas</h3>
<div class="paragraph">
<p>Der Namensraum von RELAX NG ist <code>http://relaxng.org/ns/structure/1.0</code>. Mit dem »Attribut«</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">xmlns="http://relaxng.org/ns/structure/1.0"</code></pre>
</div>
</div>
<div class="paragraph">
<p>wird dieser Namensraum als Voreinstellung für alle (Kind-)Elemente genommen. Man kann jedoch genau so gut einen Präfix nutzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">xmlns:rng="http://relaxng.org/ns/structure/1.0"</code></pre>
</div>
</div>
<div class="paragraph">
<p>dann müssen alle Elemente dieses Präfix benutzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;rng:element name="addressBook" xmlns:rng="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;rng:zeroOrMore&gt;
    &lt;rng:element name="card"&gt;
      &lt;rng:element name="name"&gt;
        &lt;rng:text/&gt;
      &lt;/rng:element&gt;
      &lt;rng:element name="email"&gt;
        &lt;rng:text/&gt;
      &lt;/rng:element&gt;
    &lt;/rng:element&gt;
  &lt;/rng:zeroOrMore&gt;
&lt;/rng:element&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_optionale_elemente_und_attribute">3. Optionale Elemente und Attribute</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Möchte man ein Element als optional markieren, macht man das wie folgt:</p>
</div>
<code class="sidebar">
optional</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;element name="name"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
      &lt;optional&gt;
        &lt;element name="note"&gt;
          &lt;text/&gt;
        &lt;/element&gt;
      &lt;/optional&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Element <code>note</code> ist nun als Kind von <code>card</code> erlaubt, muss aber nicht angegeben werden.
Genauso funktioniert dies mit Attributen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;attribute name="name"/&gt;
      &lt;attribute name="email"/&gt;
      &lt;optional&gt;
        &lt;attribute name="note" /&gt;
      &lt;/optional&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Attribut <code>note</code> kann angegeben werden.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_auswahl_choice">4. Auswahl (Choice)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Mit dem Element <code>choice</code> kann man ein »Entweder/Oder«-Konstrukt erzeugen.
Wenn das Adressbuch beispielsweise entweder das Element <code>name</code> oder die beiden Elemente <code>givenName</code> und <code>familyName</code> haben soll, nutzt man <code>choice</code>. Die gewünschte XML-Datei ist folgende:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;addressBook&gt;
  &lt;card&gt;
    &lt;givenName&gt;John&lt;/givenName&gt;
    &lt;familyName&gt;Smith&lt;/familyName&gt;
    &lt;email&gt;js@example.com&lt;/email&gt;
  &lt;/card&gt;
  &lt;card&gt;
    &lt;name&gt;Fred Bloggs&lt;/name&gt;
    &lt;email&gt;fb@example.net&lt;/email&gt;
  &lt;/card&gt;
&lt;/addressBook&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dazu passt diese Schemadatei.</p>
</div>
<code class="sidebar">
choice<br>
group
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;choice&gt;
        &lt;element name="name"&gt;
          &lt;text/&gt;
        &lt;/element&gt;
        &lt;group&gt;
          &lt;element name="givenName"&gt;
            &lt;text/&gt;
          &lt;/element&gt;
          &lt;element name="familyName"&gt;
            &lt;text/&gt;
          &lt;/element&gt;
        &lt;/group&gt;
      &lt;/choice&gt;
      &lt;element name="email"&gt;
        &lt;text/&gt;
      &lt;/element&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Element <code>group</code> hier ist notwendig, sonst wäre die Aussage »entweder <code>name</code> oder <code>givenName</code> oder <code>familyName</code>«. Dasselbe funktioniert auch für Attribute:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;choice&gt;
        &lt;attribute name="name" /&gt;
        &lt;group&gt;
          &lt;attribute name="givenName" /&gt;
          &lt;attribute name="familyName" /&gt;
        &lt;/group&gt;
      &lt;/choice&gt;
      &lt;attribute name="email"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Choice kann man auch für Kombinationen von Elementen und Attribute nutzen, wenn man z.B. »entweder Element oder Attribut« beschreiben möchte.
Im nächsten Beispiel kann man entweder das Attribut oder das Element benutzen, und zwar für jedes der beiden Felder <code>name</code> und <code>email</code> separat.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;

      &lt;choice&gt;
        &lt;element name="name"&gt;
          &lt;text/&gt;
        &lt;/element&gt;
        &lt;attribute name="name"&gt;
          &lt;text/&gt;
        &lt;/attribute&gt;
      &lt;/choice&gt;

      &lt;choice&gt;
        &lt;element name="email"&gt;
          &lt;text/&gt;
        &lt;/element&gt;
        &lt;attribute name="email"&gt;
          &lt;text/&gt;
        &lt;/attribute&gt;
      &lt;/choice&gt;

    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dieses Schema passt auf folgende XML-Dokumente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;card name="John Smith" email="js@example.com"/&gt;
&lt;card email="js@example.com" name="John Smith"/&gt;
&lt;card email="js@example.com"&gt;&lt;name&gt;John Smith&lt;/name&gt;&lt;/card&gt;
&lt;card name="John Smith"&gt;&lt;email&gt;js@example.com&lt;/email&gt;&lt;/card&gt;
&lt;card&gt;&lt;name&gt;John Smith&lt;/name&gt;&lt;email&gt;js@example.com&lt;/email&gt;&lt;/card&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Aber nicht auf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;card&gt;&lt;email&gt;js@example.com&lt;/email&gt;&lt;name&gt;John Smith&lt;/name&gt;&lt;/card&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>weil das Element <code>email</code> nicht vor dem Element <code>name</code> auftreten darf.
Erinnerung: das zweite Beispiel oben ist erlaubt, weil ja bei den Attributen die Reihenfolge unwichtig ist.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_benannte_muster">5. Benannte Muster</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Für alle größeren Schemadateien ist es vorteilhaft, wenn man das Schema in einzelne Teile gliedert. Mit <code>define</code> kann man einen einzelnen Abschnitt definieren und einen Namen zuweisen, auf dem man später mit <code>ref</code> verweisen kann.
Eine solche Definition sieht so aus:</p>
</div>
<code class="sidebar">
define
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;define name="cardContent"&gt;
  &lt;element name="name"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
  &lt;element name="email"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
&lt;/define&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>da nun aber bei mehreren solchen Definition unklar ist, wo das Schema »anfängt«, muss eine andere Struktur her.
Das Grundgerüst ist nun folgendes:</p>
</div>
<code class="sidebar">
grammer<br>
start
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;start&gt;
    &lt;element name="wurzelelement"&gt;
      ...
    &lt;/element&gt;
  &lt;/start&gt;
&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jetzt kann das bekannte Schema in Teile zerlegt werden:</p>
</div>
<code class="sidebar">
ref
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
        &lt;element name="card"&gt;
          &lt;ref name="cardContent"/&gt;
        &lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="cardContent"&gt;
    &lt;element name="name"&gt;&lt;text /&gt;&lt;/element&gt;
    &lt;element name="email"&gt;&lt;text /&gt;&lt;/element&gt;
  &lt;/define&gt;
&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Man kann das auch noch weiter treiben, in dem man die beiden Elemente aus <code>card</code> auch noch aufteilt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- der Rahmen wie oben --&gt;
  &lt;define name="cardContent"&gt;
    &lt;ref name="namecontent"/&gt;
    &lt;ref name="emailcontent"/&gt;
  &lt;/define&gt;

  &lt;define name="namecontent"&gt;
    &lt;element name="name"&gt;
      &lt;text /&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="emailcontent"&gt;
    &lt;element name="email"&gt;
      &lt;text /&gt;
    &lt;/element&gt;
  &lt;/define&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Reihenfolge der Definitionen ist beliebig. Die Referenzen dürfen sich auch selbst aufrufen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">  &lt;define name="inline"&gt;
    &lt;choice&gt;
      &lt;text/&gt;
      &lt;element name="bold"&gt;
        &lt;ref name="inline"/&gt;
      &lt;/element&gt;
      &lt;element name="italic"&gt;
        &lt;ref name="inline"/&gt;
      &lt;/element&gt;
      &lt;element name="span"&gt;
        &lt;optional&gt;
          &lt;attribute name="style"/&gt;
        &lt;/optional&gt;
        &lt;ref name="inline"/&gt;
      &lt;/element&gt;
    &lt;/choice&gt;
  &lt;/define&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Die Elemente <code>bold</code>, <code>italic</code> und <code>span</code> dürfen entweder Text enthalten oder eines der Elemente <code>bold</code>, <code>italic</code> oder <code>span</code>, und das mit beliebiger Schachtelungstiefe.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_datentypen">6. Datentypen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In den letzten Beispielen gab es als einzigen Datentyp »text«, der alles beinhaltet.
Manchmal ist es jedoch wünschenswert, nur bestimmte Werte zuzulassen, beispielsweise für das Geburtsjahr.
Der Anwender soll genau vier Ziffern in das Feld schreiben dürfen, die ggf. noch innerhalb eines Wertebereiches liegen.</p>
</div>
<div class="paragraph">
<p>RELAX NG selber kennt keine Datentypen, kann aber »externe« Datentypen einbinden.
Die wohl am häufigsten benutzte Sammlung an Datentypen hat den URI <code>http://www.w3.org/2001/XMLSchema-datatypes</code>. Dieser Identifier wird im Attribut <code>datatypeLibrary</code> angegeben, das man am einfachsten am Wurzelelement mit angibt:</p>
</div>
<code class="sidebar">
datatypeLibrary
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar
  xmlns="http://relaxng.org/ns/structure/1.0"
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"&gt;
  &lt;start&gt;
     ...
  &lt;/start&gt;
&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>bzw.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element xmlns="http://relaxng.org/ns/structure/1.0"
  datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes"
  name="addressBook"&gt;
  ...
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Möchte man ein Element einschränken auf einen bestimmten Wert, kann man das mit dem Muster <code>data</code> erreichen:</p>
</div>
<code class="sidebar">
data
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="year"&gt;
  &lt;data type="gYear"/&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das erlaubt nur Eingaben, die dem Muster <code>gYear</code> entsprechen.
Die Beschreibung der eingebauten Typen ist unter <code><a href="https://www.w3.org/TR/xmlschema-2/#built-in-datatypes" class="bare">https://www.w3.org/TR/xmlschema-2/#built-in-datatypes</a></code> zu finden.</p>
</div>
<div class="paragraph">
<p>Nicht erlaubt ist es, verschiedene Datentypen in einem Element zu benutzen.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;!-- nicht erlaubt! --&gt;
&lt;element name="year"&gt;
  &lt;data type="gYear"/&gt;
  &lt;element name="note"&gt;
    &lt;text/&gt;
  &lt;/element&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Datentypen können Parameter (Einschränkungen) haben. So sind für den Datentyp <a href="https://www.w3.org/TR/xmlschema-2/#string"><code>string</code></a> die folgenden Einschränkungen möglich:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>length</code></p>
</li>
<li>
<p><code>minLength</code></p>
</li>
<li>
<p><code>maxLength</code></p>
</li>
<li>
<p><code>pattern</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Die beiden Parameter <code>enumeration</code> und <code>whiteSpace</code> sind laut den <a href="http://relaxng.org/xsd-20010907.html">Richtlinien für Datentypen in RELAX NG</a> nicht erlaubt.</p>
</div>
<div class="paragraph">
<p>Diese Parameter werden als Kindelement von <code>data</code> angegeben</p>
</div>
<code class="sidebar">
param
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="email"&gt;
  &lt;data type="string"&gt;
    &lt;param name="minLength"&gt;6&lt;/param&gt;
    &lt;param name="maxLength"&gt;127&lt;/param&gt;
  &lt;/data&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_vorbelegte_werte">7. Vorbelegte Werte</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Manchmal möchte man Werte von Elementen oder Attributen auf eine begrenzte Anzahl von Auswahlmöglichkeiten einschränken.
Dafür gibt es das Muster <code>value</code>:</p>
</div>
<code class="sidebar">
value
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="card"&gt;
  &lt;attribute name="name"/&gt;
  &lt;attribute name="email"/&gt;
  &lt;attribute name="preferredFormat"&gt;
    &lt;choice&gt;
      &lt;value&gt;html&lt;/value&gt;
      &lt;value&gt;text&lt;/value&gt;
    &lt;/choice&gt;
  &lt;/attribute&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Analog funktioniert das auch mit Elementinhalten.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="preferredFormat"&gt;
  &lt;choice&gt;
    &lt;value&gt;html&lt;/value&gt;
    &lt;value&gt;text&lt;/value&gt;
  &lt;/choice&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Vorsicht: Dieses Muster schränkt zwar die Werte auf <code>html</code> und <code>text</code> ein, erlaubt aber Leerzeichen (Whitespace) am Anfang und am Ende des Wertes. So ist</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;preferredFormat&gt; html &lt;/preferredFormat&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ein gültiger Wert für das <code>value</code>-Muster oben. Um das zu verhindern kann man dem Element <code>value</code> mit dem Attribut <code>type</code> einschränken:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="preferredFormat"&gt;
  &lt;choice&gt;
    &lt;value type="string"&gt;html&lt;/value&gt;
    &lt;value type="string"&gt;text&lt;/value&gt;
  &lt;/choice&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Ist keine datatypeLibrary festgelegt (siehe das vorherige Kapitel), dann werden die internen Typen <code>token</code> oder <code>string</code> genommen, die dem ersten (mit Whitespace) bzw. dem zweiten genannten Verhalten (ohne Whitespace) entsprechen.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_listen">8. Listen</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Dieses Muster passt auf eine durch Leerzeichen (Whitespace) separierte Liste von Werten.
Ein einfaches Beispiel erklärt das wohl am besten:</p>
</div>
<code class="sidebar">
list
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="vector"&gt;
  &lt;list&gt;
    &lt;data type="float"/&gt;
    &lt;data type="float"/&gt;
  &lt;/list&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Auf dieses Schema passt z.B. folgendes XML-Dokument:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;vector&gt;
  1.2
  3.2
&lt;/vector&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wichtig ist nur, dass die Werte durch Leerzeichen oder ähnliches getrennt werden.</p>
</div>
<div class="paragraph">
<p>Die folgenden beiden Definitionen zeigen die Anwendungsmöglichkeiten:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="vector"&gt;
  &lt;list&gt;
    &lt;oneOrMore&gt;
      &lt;data type="double"/&gt;
    &lt;/oneOrMore&gt;
  &lt;/list&gt;
&lt;/element&gt;

&lt;element name="path"&gt;
  &lt;list&gt;
    &lt;oneOrMore&gt;
      &lt;data type="double"/&gt;
      &lt;data type="double"/&gt;
    &lt;/oneOrMore&gt;
  &lt;/list&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Im ersten Fall sind ein oder mehrere Werte vom Typ <code>double</code> erlaubt, im zweiten Fall sind eine gerade Anzahl der Werte erlaubt.</p>
</div>
<div class="paragraph">
<p>In der Praxis spielen diese Listen vermutlich nicht so eine große Rolle.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_verschachteln_von_elementen_interleave">9. Verschachteln von Elementen (interleave)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Das Interleave-Muster erlaubt es,  Kindelemente in beliebiger Reihenfolge auftreten zu lassen.
Im folgenden Beispiel können die Kindelemente von <code>card</code> in der Reihenfolge <code>email</code> und dann <code>name</code> oder andersrum auftreten.</p>
</div>
<code class="sidebar">
interleave
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;interleave&gt;
    	 &lt;element name="name"&gt;
    	   &lt;text/&gt;
    	 &lt;/element&gt;
    	 &lt;element name="email"&gt;
    	   &lt;text/&gt;
    	 &lt;/element&gt;
      &lt;/interleave&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mit Interleave sind aber weitaus mächtigere Konstrukte möglich.
Als Beispiel dient der Kopf einer HTML-Seite (Elementname <code>head</code>).
In dem Kopf sind verschiedene Regeln zu beachten:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Es ist ein Vorkommen der Elemente <code>title</code> und <code>base</code> erlaubt, letzteres ist jedoch optional.</p>
</li>
<li>
<p>Die Elemente <code>style</code>, <code>script</code>, <code>link</code> und <code>meta</code> dürfen mehrfach vorkommen, sind aber auch optional.</p>
</li>
<li>
<p>Die Reihenfolge der Elemente ist beliebig.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Unter der Annahme, dass es für die <code>&lt;ref name="&#8230;&#8203;"&gt;</code> passende Definitionen gibt, kann man die Regel für den HTML-Kopf mit dem folgenden Muster beschreiben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;define name="head"&gt;
  &lt;element name="head"&gt;
    &lt;interleave&gt;
      &lt;ref name="title"/&gt;
      &lt;optional&gt;
        &lt;ref name="base"/&gt;
      &lt;/optional&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="style"/&gt;
      &lt;/zeroOrMore&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="script"/&gt;
      &lt;/zeroOrMore&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="link"/&gt;
      &lt;/zeroOrMore&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="meta"/&gt;
      &lt;/zeroOrMore&gt;
    &lt;/interleave&gt;
  &lt;/element&gt;
&lt;/define&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier ist eine Eigenschaft zu erwähnen, die vielleicht nicht unbedingt intuitiv ist.
Das Muster oben erlaubt die folgende XML-Datei:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;head&gt;
  &lt;meta  ... /&gt;
  &lt;title ... /&gt;
  &lt;meta  ... /&gt;
&lt;/head&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Man könnte vermuten, dass die <code>meta</code>-Elemente hintereinander stehen müssen, weil sie durch <code>zeroOrMore</code> gekennzeichnet sind.</p>
</div>
<h3 id="_gemischter_inhalt_mixed_content" class="discrete">Gemischter Inhalt (mixed content)</h3>
<div class="paragraph">
<p>Für einen Sonderfall des Interleave-Musters gibt es ein extra Element. Wenn ein Muster p auch Text beinhalten darf (mixed content), dann kann man</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;interleave&gt; &lt;text/&gt; p &lt;/interleave&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>durch</p>
</div>
<code class="sidebar">
mixed
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;mixed&gt; p &lt;/mixed&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>abkürzen.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mehrfachdefinitionen_combine">10. Mehrfachdefinitionen (combine )</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Ein Schema kann mehrere Definitionen (<code>define</code>) mit demselben Namen enthalten.
Dann muss allerdings beschrieben werden, was passiert, wenn mehrere Definitionen zu einer zusammengeführt werden.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Warum sollte man mehrere Definitionen mit demselben Namen haben? Das spielt dann eine wichtige Rolle, wenn man mehrere Schemadateien hat und diese kombinieren will. Mehr dazu im nächsten Abschnitt.
</td>
</tr>
</table>
</div>
<code class="sidebar">
combine
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;define name="inline" combine="choice"&gt;
  &lt;element name="bold"&gt;
    &lt;ref name="inline"/&gt;
  &lt;/element&gt;
&lt;/define&gt;

&lt;define name="inline" combine="choice"&gt;
  &lt;element name="italic"&gt;
    &lt;ref name="inline"/&gt;
  &lt;/element&gt;
&lt;/define&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ist dasselbe wie</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;define name="inline"&gt;
  &lt;choice&gt;
    &lt;element name="bold"&gt;
      &lt;ref name="inline"/&gt;
    &lt;/element&gt;
    &lt;element name="italic"&gt;
      &lt;ref name="inline"/&gt;
    &lt;/element&gt;
  &lt;/choice&gt;
&lt;/define&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Für Attribute wird in der Regel <code>combine="interleave"</code> benutzt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
        &lt;element name="card"&gt;
          &lt;ref name="card.attlist"/&gt;
        &lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="card.attlist" combine="interleave"&gt;
    &lt;attribute name="name"&gt;
      &lt;text/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

  &lt;define name="card.attlist" combine="interleave"&gt;
    &lt;attribute name="email"&gt;
      &lt;text/&gt;
    &lt;/attribute&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ist dasselbe wie</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
        &lt;element name="card"&gt;
          &lt;ref name="card.attlist"/&gt;
        &lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="card.attlist"&gt;
    &lt;interleave&gt;
      &lt;attribute name="name"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
      &lt;attribute name="email"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
    &lt;/interleave&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>was wiederum dasselbe ist wie</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
        &lt;element name="card"&gt;
          &lt;ref name="card.attlist"/&gt;
        &lt;/element&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

  &lt;define name="card.attlist"&gt;
    &lt;group&gt;
      &lt;attribute name="name"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
      &lt;attribute name="email"&gt;
        &lt;text/&gt;
      &lt;/attribute&gt;
    &lt;/group&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>weil die Kombination von Attributen per Interleave denselben Effekt hat wie die Kombination in einer Gruppe.</p>
</div>
<div class="paragraph">
<p>Es gibt noch ein paar beachtenswerte Regeln bei Mehrfachdefinitionen:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Alle Vorkommen einer Definition müssen denselben Wert bei <code>combine</code> haben.</p>
</li>
<li>
<p>Bei einer Definition darf das Attribut <code>combine</code> weggelassen werden. Es wird dann der Wert der anderen Definitionen benutzt.</p>
</li>
<li>
<p>Die Reihenfolge der Definitionen ist irrelevant.</p>
</li>
<li>
<p>Mehrere Startelemente (<code>start</code>) werden wie Definitionen behandelt und können kombiniert werden.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_mehrere_schemadateien">11. Mehrere Schemadateien</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Man kann anstelle einer Schemadatei mehrere verwenden.
DocBook sei hier als Beispiel erwähnt:
DocBook bietet eine <a href="http://docbook.org/xml/5.0/rng/docbookxi.rng">große Schemadatei zum herunterladen</a> an.
Möchte man eigene Erweiterungen zu DocBook hinzufügen, ändert man nicht diese Hauptdatei, sondern schreibt die Erweiterungen in eine eigene Schemadatei und verwendet die eigene als Schema für das XML-Dokument.</p>
</div>
<div class="paragraph">
<p>Es gibt zwei Arten der Referenzierung: <code>externalRef</code> und <code>include</code>.
Die erste Variante bietet sich an, wenn man kleinere Definitionen hat, die man aus verschiedenen Hauptdateien einbindet und die zweite Variante bietet sich in Situationen an wie im DocBook-Beispiel beschrieben.</p>
</div>
<div class="sect2">
<h3 id="_referenz_auf_externe_muster">11.1. Referenz auf externe Muster</h3>
<div class="paragraph">
<p>Wenn wir eine einfache Datei haben (<code>card.rng</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar  xmlns="http://relaxng.org/ns/structure/1.0"&gt;
  &lt;start&gt;
    &lt;ref name="card"/&gt;
  &lt;/start&gt;

  &lt;define name="card"&gt;
    &lt;element name="card"&gt;&lt;empty/&gt;&lt;/element&gt;
  &lt;/define&gt;
&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>kann man auf das Startelement per <code>externalRef</code> zugreifen:</p>
</div>
<code class="sidebar">
externalRef
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
        &lt;externalRef href="card.rng"/&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Man kann dieses Muster auch bei <code>choice</code> benutzen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;choice&gt;
  &lt;externalRef href="pattern1.rng"/&gt;
  &lt;externalRef href="pattern2.rng"/&gt;
&lt;/choice&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Fantasie sind hier kaum Grenzen gesetzt. In der Praxis findet sich jedoch etwas häufiger der folgende Mechanismus:</p>
</div>
</div>
<div class="sect2">
<h3 id="_zusammenführen_von_schemadateien">11.2. Zusammenführen von Schemadateien</h3>
<div class="paragraph">
<p>Mit dem <code>include</code> Befehl lassen sich Schemadateien zusammenführen.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Das <code>include</code>-Element hat zwei verschiedene Semantiken, je nach dem wie man es benutzt. In diesem Abschnitt wird <code>include</code> benutzt, um Definitionen zu ergänzen (<code>combine</code>), im nächsten Abschnitt wird <code>include</code> benutzt, um Definitionen zu ersetzen. Ein feiner, aber sehr wichtiger Unterschied!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Es sei eine Datei gegeben, die ein Adressbuch definiert (<code>addressbook.rng</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="card" /&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;


  &lt;define name="card"&gt;
    &lt;element name="card"&gt;
      &lt;ref name="card.attributes" /&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="card.attributes"&gt;
    &lt;attribute name="name"/&gt;
    &lt;attribute name="email"/&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dieses Schema sollte nach dem Studium der letzten Abschnitte leicht zu lesen sein.
Es erlaubt eine Datei der folgenden Form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;addressBook&gt;
  &lt;card name="..." email="..." /&gt;
  &lt;card name="..." email="..." /&gt;
  ...
&lt;/addressBook&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Möchten wir die Definitionen oben erweitern, fangen wir am besten mit der trivialen Datei an (<code>schema.rng</code>):</p>
</div>
<code class="sidebar">
include
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;include href="addressbook.rng"/&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In diesem Zustand ist es egal, ob gegen <code>schema.rng</code> oder gegen <code>addressbook.rng</code> validiert wird, weil der Inhalt identisch ist.
Erweitern wir nun die Definitionen aus <code>addressbook.rng</code> in der neuen Datei, dann muss ausschließlich gegen die neue Datei validiert werden, sonst werden die Erweiterungen nicht beachtet.</p>
</div>
<div class="paragraph">
<p>Die erste Erweiterung besteht darin, dass ein optionales Attribut <code>note</code> in einem Eintrag benutzt werden darf:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;include href="addressbook.rng"/&gt;

  &lt;define name="card.attributes" combine="interleave"&gt;
    &lt;optional&gt;
      &lt;attribute name="note"/&gt;
    &lt;/optional&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Im letzten Abschnitt wurde erwähnt, dass Attribute mit <code>choice="interleave"</code> verbunden werden sollten.</p>
</div>
<div class="paragraph">
<p>Damit ist nun ein optionales Attribut <code>note</code> erlaubt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;addressBook&gt;
  &lt;card name="..." email="..." /&gt;
  &lt;card name="..." email="..." note="..." /&gt;
  ...
&lt;/addressBook&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ersetzen_von_definitionen">11.3. Ersetzen von Definitionen</h3>
<div class="paragraph">
<p>Schreibt man die neuen Definitionen <em>in</em> das <code>include</code>-Element, so werden die alten Definitionen überschrieben. Das ist ein Unterschied zu der vorherigen Benutzung von <code>include</code>.</p>
</div>
<div class="paragraph">
<p>Es sei wieder die Datei gegeben, die ein Adressbuch definiert (<code>addressbook.rng</code>). Unsere neue <code>schema.rng</code> ist nun wie folgt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;include href="addressbook.rng"&gt;
    &lt;define name="card.attributes"&gt;
      &lt;attribute name="familyName"/&gt;
      &lt;attribute name="givenName"/&gt;
    &lt;/define&gt;
  &lt;/include&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hier steht die Definition innerhalb des <code>include</code>-Elements. Daher wird die Definition der erlaubten Attribute überschrieben.
Eine gültige XML-Datei hat nun die Form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;addressBook&gt;
  &lt;card familyName="..." givenName="..."/&gt;
  &lt;card familyName="..." givenName="..."/&gt;
&lt;/addressBook&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Tipp: Die <code>include</code>-Anweisung darf auch das <code>start</code>-Element enthalten, das dann das <code>start</code>-Element der eingebundenen Datei überschreibt.</p>
</div>
</div>
<div class="sect2">
<h3 id="_platzhalter">11.4. Platzhalter</h3>
<div class="paragraph">
<p>Es gibt ein Element <code>notAllowed</code>, das als Platzhalter für Erweiterungen dienen kann.</p>
</div>
<div class="paragraph">
<p>Im einfachsten Fall wird es so benutzt:</p>
</div>
<code class="sidebar">
notAllowed
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="einElement"&gt;
  &lt;notAllowed/&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Wie der Name schon sagt, ist ein Element, das <code>notAllowed</code> enthält, in einer XML-Datei verboten.</p>
</div>
<div class="paragraph">
<p>Es bietet sich aber folgendes Muster an, Erweiterungen einer Auswahlliste zu ermöglichen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;start&gt;
    &lt;element name="auswahlliste"&gt;
      &lt;zeroOrMore&gt;
        &lt;ref name="auswahl"/&gt;
      &lt;/zeroOrMore&gt;
    &lt;/element&gt;
  &lt;/start&gt;


  &lt;define name="auswahl"&gt;
    &lt;element name="auswahl"&gt;
      &lt;choice&gt;
        &lt;element name="eins"&gt;&lt;empty /&gt;&lt;/element&gt;
        &lt;element name="zwei"&gt;&lt;empty /&gt;&lt;/element&gt;
        &lt;ref name="auswahl.extras"/&gt;
      &lt;/choice&gt;
    &lt;/element&gt;
  &lt;/define&gt;

  &lt;define name="auswahl.extras"&gt;
    &lt;notAllowed/&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ein <code>notAllowed</code>-Element als Teil einer Auswahl (<code>choice</code>) wird einfach ignoriert.
Nun kann man die Auswahlliste in einer eigenen Datei erweitern:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;include href="auswahlliste.rng"/&gt;

  &lt;define name="auswahl.extras" combine="choice"&gt;
    &lt;element name="drei"&gt;
      &lt;empty /&gt;
    &lt;/element&gt;
  &lt;/define&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_namensräume_namespaces">12. Namensräume (Namespaces)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>RELAX NG kann mit XML-Namensräumen umgehen.
Damit ist nicht der Namensraum der Schemadatei gemeint, sondern die Namensräume der zu validierenden XML-Datei.
Diese kann keinen oder mehrere Namensräume enthalten.
Namensräume sind fester Bestandteil einer XML-Datei und daher muss das Schema diese Namensräume prüfen können.</p>
</div>
<div class="paragraph">
<p>Für diejenigen, die sich nicht so sicher sind, wie die XML-Namensräume funktionieren, gibt es hier eine Auffrischung:</p>
</div>
<div class="sect2">
<h3 id="_auffrischung_xml_namensräume">12.1. Auffrischung: XML-Namensräume</h3>
<div class="paragraph">
<p>Ein Elementname oder ein Attributname besteht immer aus einem lokalen Namen und einem ggf. leerem  Namensraum.
Der Namensraum hat zur Kennung einen (fast beliebigen) Präfix und ist ein sogenannter »uniform resource identifier« (URI).</p>
</div>
<div class="paragraph">
<p>In XML werden Namensräume zweistufig angewendet. Die erste Stufe ist es, einem Präfix einen URI zuzuweisen:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>xmlns:ex="http://example.com"</pre>
</div>
</div>
<div class="paragraph">
<p>Anschließend kann das Präfix wie folgt benutzt werden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ex:elementname /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>In diesem Fall hat das Element den lokalen Namen <code>elementname</code> und den Namensraum <code>http://example.com</code>.
Das benutzte Präfix ist egal (in manchen Fällen spielt er dennoch eine Rolle, aber das sei hier vernachlässigt).
Der Namensraum sieht häufig aus wie eine URL, ist es aber nicht! Es ist nur ein beliebiger, möglichst eindeutiger String.</p>
</div>
<div class="paragraph">
<p>Das Präfix ist optional. Wenn es weggelassen wird, spricht man von einem Default-Namespace. Die erste Stufe hat dann die Form ohne <code>:ex</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>xmlns="http://example.com"</pre>
</div>
</div>
<div class="paragraph">
<p>die zweite Stufe dann</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;elementname /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Der Namensraum (bzw. der Name) des Elements <code>elementanme</code> ist in beiden Beispielen identisch.
Es sollte keine technische Unterscheidung geben zwischen den beiden Varianten mit explizitem Namensraum und mit Default-Namensraum.</p>
</div>
<div class="paragraph">
<p>Noch ein wichtiger Hinweis. Die erste Stufe (die Zuordnung eines Präfix zu dem Namensraum) erfolgt am benutzten Element selbst oder an einem der Elternelemente. Das Beispiel oben wäre vollständig also wie folgt:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ex:elementname  xmlns:ex="http://example.com" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>oder</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;elternelement xmlns:ex="http://example.com"&gt;
  &lt;ex:elementname /&gt;
&lt;elternelement&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Im letzten Fall hat das Elternelement <em>nicht</em> den Namensraum <code>http://example.com</code>, das Kindelement schon.</p>
</div>
<div class="paragraph">
<p>Mit diesem Exkurs sollte die Anwendung von RELAX NG-Namensräumen kein Problem darstellen.</p>
</div>
</div>
<div class="sect2">
<h3 id="_benutzung_des_attributs_code_ns_code">12.2. Benutzung des Attributs <code>ns</code></h3>
<div class="paragraph">
<p>In dem Attribut <code>ns</code> kann der erwartete Namensraum einfach angegeben werden:</p>
</div>
<code class="sidebar">
ns
</code>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="foo" ns="http://example.com"&gt;
  &lt;empty/&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Dieses Schema passt auf folgende Elemente:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;foo xmlns="http://example.com"/&gt;
&lt;e:foo xmlns:e="http://example.com"/&gt;
&lt;example:foo xmlns:example="http://example.com"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>aber nicht auf diese hier:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;foo/&gt;
&lt;e:foo xmlns:e="http://EXAMPLE.COM"/&gt;
&lt;example:foo xmlns:example="http://example.net"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Ist ds Attribut <code>ns</code> leer, so wird ein leerer Namensraum erwartet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="foo" ns=""&gt;
  &lt;empty/&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>passt auf diese Elemente</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;foo xmlns=""/&gt;
&lt;foo/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>aber nicht auf folgende:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;foo xmlns="http://example.com"/&gt;
&lt;e:foo xmlns:e="http://example.com"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Attribut <code>ns</code> muss nicht an jedem Element angegeben werden. Das Schema sucht nach dem nächsten Elternelement, das ein solches Attribut hat. So kann man einen Namensraum, der für die ganze XML-Datei gilt, auch am Wurzelelement <code>grammer</code> angeben:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar
  xmlns="http://relaxng.org/ns/structure/1.0"
  ns="http://example.com"&gt;

  &lt;start&gt;
    &lt;element name="addressBook"&gt;
      &lt;empty/&gt;
    &lt;/element&gt;
  &lt;/start&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das Element <code>addressBook</code> wird im Namensraum <code><a href="http://example.com" class="bare">http://example.com</a></code> erwartet.</p>
</div>
<div class="paragraph">
<p>Nochmals der Hinweis: der Eintrag <code>xmlns="http://relaxng.org/ns/structure/1.0"</code> ist nur dafür da, die Schemadatei als RELAX NG Datei zu kennzeichnen und hat nichts mit dem zu überprüfenden XML-Dokument zu tun.</p>
</div>
</div>
<div class="sect2">
<h3 id="_namensräume_in_attributen">12.3. Namensräume in Attributen</h3>
<div class="paragraph">
<p>Eine Besonderheit bei Namensräumen in Attributen ist meiner Meinung eine Schwachstelle der Definition von XML-Namensräumen.
Die Attribute eines Elements befinden sich <em>nicht</em> in demselben Namensraum des umschließenden Elements. D.h. im Beispiel von oben</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;elementname attrib="wert"  xmlns="http://example.com" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ist das Attribut <code>attrib</code> nicht im selben Namensraum wie das Element.</p>
</div>
<div class="paragraph">
<p>Daher ist die Voreinstellung für Attribute der leere Namensraum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" ns="http://example.com"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card"&gt;
      &lt;attribute name="name"/&gt;
      &lt;attribute name="email"/&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>ist identisch zu:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;element name="addressBook" ns="http://example.com"&gt;
  &lt;zeroOrMore&gt;
    &lt;element name="card" ns="http://example.com"&gt;
      &lt;attribute name="name" ns=""/&gt;
      &lt;attribute name="email" ns=""/&gt;
    &lt;/element&gt;
  &lt;/zeroOrMore&gt;
&lt;/element&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_namensräume_mit_qualifizierten_namen">12.4. Namensräume mit qualifizierten Namen</h3>
<div class="paragraph">
<p>Anstelle des Attributs <code>ns</code> wie oben beschrieben können die Namensräume auch direkt angegeben werden:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;grammar
  xmlns="http://relaxng.org/ns/structure/1.0"&gt;

  &lt;start xmlns:ex="http://example.com"&gt;
    &lt;element name="ex:addressBook"&gt;
      ...
    &lt;/element&gt;
  &lt;/start&gt;

&lt;/grammar&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>passt auf folgende XML-Datei:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml" data-lang="xml">&lt;ex:addressBook  xmlns:ex="http://example.com" &gt;
  ...
&lt;/ex:addressBook&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Das ist hilfreich, wenn mehrere Namensräume in der zu validierenden XML-Datei vorkommen und man sich die mehrfache Angabe des Attributs <code>ns</code> ersparen möchte. Die direkte Angabe mit qualifizierten Namen hat Vorrang vor der Angabe des Attributs <code>ns</code>.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 0.1<br>
Last updated 2017-08-03 11:56:58 CEST
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/styles/github.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.9.1/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html><script data-no-instant>document.write('<script src="/livereload.js?port=8888&mindelay=10"></' + 'script>')</script>